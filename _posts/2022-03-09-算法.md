---
layout:     post
title:      算法
date:       2022-02-23
author:     shaokang
catalog: true
tags:
    - 复习
---
## 引言
最近在看一本算法书《labuladong 的算法小抄》，作者对各种算法问题提炼出了基础的解法框架，能够帮助读者快速理解各算法中的精髓。这里我将此记录下来，帮助自己日后快速回顾。

## 回溯算法
### 核心框架
```js
result = [];
def backtrack( 路径，选择列表 ):
    if 满足结束条件 :
        result.add( 路径);
        return;
    for 选择 in 选择列表 ：
        做选择
        backtrack( 路径，选择列表 )
        撤销选择
```

### 经典例子：全排列问题
```js
let permute = function (nums) {
    const result = [];
    backtrack(nums, arr, result);
    return result;
}

let backtrack = function (nums, track, result) {
    if (track.length === nums.length) {
        result.push([...track]);
        return;
    }

    for (let i = 0; i < nums.length; i++) {
        if (track.includes(nums[i])) {
            continue;
        }

        track.push(nums[i]);
        backtrack(nums, track, result);
        track.pop();
    }
}
```

## 广度优先遍历框架
### 核心框架：
```java
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点，这里判断是否到达终点 */
            if (cur is target) {
                return step;
            }

            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj()) {
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
            }
        }
        /* 划重点，在这里更新步数 */
        step++;
    }

}
```

### 经典问题：二叉树的最小高度
```js
var BFS = function(root) {
    if (root === null) return 0;
    var queue = [root];
    var depth = 1;
    while (queue.length !== 0) {
        var cur = queue.shift();
        for (var i = 0; i < queue.length; i++) {
            if (cur.left === null && cur.right === null) {
                return depth;
            }

            if (cur.left !== null) {
                queue.push(cur.left);
            }

            if (cur.right !== null) {
                queue.push(cur.right);
            }
        }
        depth++;
    }
}
```

## 深度优先遍历框架
深度优先遍历其实就是递归的过程
例：二叉树的先序遍历

### 递归
```js
void traverse(TreeNode root) {
    if (root === null) return;

    /* 前序遍历的代码 */
    print(root.val);

    traverse(root.left);
    traverse(root.right);
}
```

### 遍历
```c++
void traverse(TreeNode root) {
    if (root === null) return;

    Stack<Node> stack;
    stack.push(root);

    while (!stack.empty()) {
        Node node = stack.top();

        stack.pop();

        if (node.right != null) {
            stack.push(node.right);
        }

        if (node.left != null) {
            stack.push(node.left);
        }

        /* 输出 */
        print(node.val);
    }
}
```

## 快排
```js
function quickSort(arr) {
    if (arr.length <= 1)  {
        return arr;
    }
    var pivotIndex = Math.floor(arr.length / 2);
    var pivot = arr.splice(pivotIndex, 1)[0];
    var left = [],right = [];
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i]);
        }
        else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat([pivot], quickSort(right));
}
```

## 滑动窗口
### 核心框架
```js
let left = 0, right = 0;

while (right < s.length) {
    window.add(s[right]);
    right++;

    while (window needs shrink) {
        window.remove(s[left]);
        left++;
    }
}
```
时间复杂度为 O（N）
```js
const slidingWindow = function (s: string, t: string) {
    const need: Record<string, number> = {};
    for (let c of t) {
        need[c] = (need[c] || 0) + 1;
    }
    const window: Record<string, number> = {};

    let left = 0, right = 0;
    let valid = 0;

    while (right < s.length) {
        // c 是移入窗口的字符
        let c = s[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...


        while (window needs shrink) {
            // d 是将移出窗口的字符
            let d = s[left];
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
```

### 经典问题：字符串的排列
判断 s1 的排列之一是 s2 的 子串。
```
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").
```

```js
const checkInclusion = function (s1, s2) {
    if (s1.length > s2.length) {
        return false;
    }

    let left = 0;
    let right = 0;
    let valid = 0;
    const window = {};
    const need = {};
    for (let c of t) {
        need[c] = (need[c] || 0) + 1;
    }

    while (right < s2.length) {
        const c = s2[right];
        right++;

        if (need[c]) {
            window[c] = (window[c] || 0) + 1;
            if (window[c] === need[c]) {
                valid++;
            }
        }

        while (right - left >= s1.length) {
            if (valid === Object.keys(need).length) {
                return true;
            }

            const d = s2[left];
            left++;
            if (need[d]) {
                if (window[d] === need[d]) {
                    valid--;
                }
                window[d] -= 1;
            }
        }
    }
    return false;
}
```

## 动态规划
动态规划分为以下几步：找到 "状态" 和 "选择" => 明确 dp 数组的定义 => 寻找 "状态" 之间的关系。

通用技巧：数学归纳法

### 经典问题：最长递增子序列
定义 dp，dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。

base case： dp[i] 初始值为 1。

假设已经知道 dp[0..4]的所有结果，如何通过这些已知结果推出 dp[5] 呢？  
只需要找到结尾小于 num[5] 的子序列，将 num[5] 接到后面，看最后那个子序列长度最大。

```js
for (let i = 0; i < nums.length; i++) {
    for (let j = 0; j < i; j++) {
        if (nums[i] > nums[j]) {
            dp[i] = Math.max(dp[i], dp[j] + 1);
        }
    }
}
```


### 最长回文子串

dp[i][j] = dp[i + 1][j - 1] && s[i] === s[j];

因为求 i,j 需要知道 i + 1, j - 1，所以 i 从 len 开始递减。并且 i 肯定是小于等于 j 的（这样才能构成字符串），j 一开始等于 i 就可以了。

最后我们就计算出了 dp table（长方形）左下一半的值.
```js
    const n = s.length;
    const dp = new Array(n).fill(false).map(() => new Array(n).fill(false));
    let maxLen = 0;
    let start = 0;
    let end = 0;

    for (let i = n - 1; i >= 0 ; i--) {
        for (let j = i; j < n; j++) {
            if (s[i] === s[j]) {
                if (j - i < 2) {
                    dp[i][j] = true;
                }
                else if (dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                }
            }

            if (dp[i][j]) {
                if (j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    start = i;
                    end = j;
                }
            }
        }
    }

    return s.substr(start, end - start + 1);
```

循环的条件也可以改一下
```js
 for (let len = 1; len <= length; len++) //遍历所有的长度
        for (let start = 0; start < length; start++) {
            let j = len + i - 1;
            // 如果右边界越界，就可以退出当前循环
            if (j >= s.length) {
                break;
            }

            if (s[i] != s[j]) {
                dp[i][j] = false;
            }
            else {
                if (j - i < 3) {
                    dp[i][j] = true;
                }
                else {
                    dp[i][j] = dp[i + 1][j - 1];
                }
            }
        }
```

## 二分查找
### 经典框架
```js
function binarySearch(nums, target) {
    while (left <= right) {
        mid = left + (right - left) / 2;

        if (nums[mid] === target) {
            return mid;
        }
        else if (nums[mid] < target) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
}
```

### 经典二分查找
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
```js
var search = function (nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (nums[mid] === target) {
            return mid;
        }
        else if (nums[mid] < target) {
            left = mid + 1;
        }
        else {
            right = mid - 1;
        }
    }
    return -1;
};
```

### 寻找左边界的二分查找
nums 数组中可能有重复元素，找出最左侧的 target
```js
var search = function (nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        // 防止两个数值过大造成溢出
        // const mid = left + Math.floor((left - right) / 2);
        if (nums[mid] < target) {
            left = mid + 1;
        }
        else {
            // 因为是要找最左侧的数，所以 = target 的时候还是要收紧边界
            // nums[mid] <= target 收缩右侧边界
            right = mid - 1;
        }
    }

    if (left >= nums.length || nums[left] !== target) {
        return -1;
    }

    return left;
};
```

### 寻找右边界的二分查找
```js
var search = function (nums, target) {
    let left = 0;
    let right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (nums[mid] > target) {
            right = mid - 1;
        }
        else {
            // nums[mid] <= target 收缩左侧边界
            left = mid + 1;
        }
    }

    if (right < 0 || nums[right] !== target) {
        return -1;
    }

    return right;
};

```