---
layout:     post
title:      算法
date:       2022-02-23
author:     shaokang
catalog: true
tags:
    - 复习
---
## 引言
最近在看一本算法书《labuladong 的算法小抄》，作者对各种算法问题提炼出了基础的解法框架，能够帮助读者快速理解各算法中的精髓。这里我将此记录下来，帮助自己日后快速回顾。

## 回溯算法
核心框架
```js
result = [];
def backtrack( 路径，选择列表 ):
    if 满足结束条件 :
        result.add( 路径);
        return;
    for 选择 in 选择列表 ：
        做选择
        backtrack( 路径，选择列表 )
        撤销选择
```

经典例子：全排列问题
```js
let permute = function (nums) {
    const result = [];
    backtrack(nums, arr, result);
    return result;
}

let backtrack = function (nums, track, result) {
    if (track.length === nums.length) {
        result.push([...track]);
        return;
    }

    for (let i = 0; i < nums.length; i++) {
        if (track.includes(nums[i])) {
            continue;
        }

        track.push(nums[i]);
        backtrack(nums, track, result);
        track.pop();
    }
}
```

## 广度优先遍历框架
核心框架：
```java
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点，这里判断是否到达终点 */
            if (cur is target) {
                return step;
            }

            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj()) {
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
            }
        }
        /* 划重点，在这里更新步数 */
        step++;
    }

}
```

经典问题：二叉树的最小高度
```js
var BFS = function(root) {
    if (root === null) return 0;
    var queue = [root];
    var depth = 1;
    while (queue.length !== 0) {
        var cur = queue.shift();
        for (var i = 0; i < queue.length; i++) {
            if (cur.left === null && cur.right === null) {
                return depth;
            }

            if (cur.left !== null) {
                queue.push(cur.left);
            }

            if (cur.right !== null) {
                queue.push(cur.right);
            }
        }
        depth++;
    }
}
```

## 深度优先遍历框架
深度优先遍历其实就是递归的过程
例：二叉树的先序遍历

递归
```js
void traverse(TreeNode root) {
    if (root === null) return;

    /* 前序遍历的代码 */
    print(root.val);

    traverse(root.left);
    traverse(root.right);
}
```

遍历
```c++
void traverse(TreeNode root) {
    if (root === null) return;

    Stack<Node> stack;
    stack.push(root);

    while (!stack.empty()) {
        Node node = stack.top();

        stack.pop();

        if (node.right != null) {
            stack.push(node.right);
        }

        if (node.left != null) {
            stack.push(node.left);
        }

        /* 输出 */
        print(node.val);
    }
}
```

## 快排
```js
function quickSort(arr) {
    if (arr.length <= 1)  {
        return arr;
    }
    var pivotIndex = Math.floor(arr.length / 2);
    var pivot = arr.splice(pivotIndex, 1)[0];
    var left = [],right = [];
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] < pivot) {
            left.push(arr[i]);
        }
        else {
            right.push(arr[i]);
        }
    }
    return quickSort(left).concat([pivot], quickSort(right));
```
