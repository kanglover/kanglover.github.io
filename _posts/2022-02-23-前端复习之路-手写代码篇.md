---
layout:     post
title:      手写代码
date:       2022-02-23
author:     shaokang
catalog: true
tags:
    - 复习
---
## Object.create
```
function create(obj) {
    function F() {}
    F.prototype = obj
    return new F()
}
```

## 实现 new
```
function myNew() {
    const obj = {} // 1
    const constructor = Array.prototype.shift.call(arguments);
    obj.__proto__ = constructor.prototype;
    const result = constructor.apply(obj, arguments);
    return typeof result === 'object' ? result : obj;
}
```

```
function myNew() {
    const constructor = Array.prototype.shift.call(arguments);
    const obj = Object.create(constructor.prototype);
    const result = constructor.apply(obj, arguments);
    return typeof result === 'object' ? result : obj;
}
```

## 实现柯里化
```
function myCurry(fn, args) {
    var len = fn.length;
    var args = args || []
    return function () {
        var _args_ = args.concat(Array.prototype.slice.call(arguments));

        if (_args.length < len) {
            return myCurry.call(this, fn, _args);
        }

        return fn.apply(this, fn, _args);
    }
}
```

## 防抖和节流
```
function debounce(fn, wait) {
    let timer = null;
    return function () {
        const context = this;
        const params = [...arguments];

        if (timer) {
            clearTimeout(timer);
        }
        timer = setTimeout(() => {
            fn.apply(this, params);
            timer = null;
        })
    }
}

function debounce(fn, wait) {
    let timer = null;
    return function (...args) {
        const context = this;

        if (timer) {
            clearTimeout(timer);
            timer = null;
        }

        // 设置定时器，使事件间隔指定事件后执行
        timer = setTimeout(() => {
            fn.apply(context, args);
        }, wait);
    };
}

// 定时器版本
function throttle(fun, wait) {
    let timeout = null
    return function (...args) {
        let context = this;

        if (!timeout) {
            timeout = setTimeout(() => {
                fun.apply(context, args)
                timeout = null;
            }, wait)
        }
    };
}

// 时间戳版
function throttle(fn, wait) {
    const oldTime = Date.now();

    return function (...args) {
        const context = this,
        const newTime = Data.now();

        if (newTime - oldTime >= delay) {
            oldTime = Data.now();
            return fn.apply(context, args);
        }
    };
}

```

## apply、call、bind

```
Function.prototype.myCall = function(context) {
    if (typeof this !== "function") {
        console.error("type error");
    }
    const args = [...arguments].slice(1);
    context = context || window;
    context.fn = this;
    const result = result = context.fn(...args);
    delete context.fn;
    return result;
}

// apply 函数实现
Function.prototype.myApply = function(context) {
    if (typeof this !== "function") {
        throw new TypeError("Error");
    }

    context = context || window;
    context.fn = this;
    let result = null;
    if (arguments[1]) {
        result = context.fn()
    }
    else {
        result = context.fn(arguments[1])
    }
    delete context.fn;
    return result;
};
```


## 异步任务调度
```
function asyncRetry(fn, times, timeout = 0) {
  // fn必需
  // times必需，且为大于0的正整数
  times = parseInt(times);
  if(times <= 0 || isNaN(times)) {
    throw new TypeError("times必需是大于0的正整数");
  }
  // Number.isInteger()

  return Promise.race([
    // 错误后重复
    new Promise(async (resolve, reject) => {
      while(times--) {
        try {
          const res = await fn();
          resolve(res);
          break;
        } catch (error) {
          if(times <= 0) {
            reject("retry error");
          }
        }
      }
    }),
    // 超时任务
    new Promise((resolve, reject) => {
      setTimeout(() => {
        reject("retry error");
      }, timeout)
    })
  ]);
}
```

## 正则
下划线转驼峰
```js
function underscoreToCamelCase(str) {
  return str.replace(/_([a-z])/g, function(match, group) {
    return group.toUpperCase();
  });
}
```
驼峰转下划线
```js
function camelCaseToUnderscore(str) {
  return str.replace(/([A-Z])/g, function(match, group) {
    return "_" + group.toLowerCase();
  });
}
```

## 实现 flat 方法
```js
function flat(arr) {
  let result = [];
  for (let i = 0; i < arr.length; i++) {
    const cur = arr[i];

    if (Array.isArray(cur)) {
      result = result.concat(flat(cur))
    }
    else {
      result.push(cur);
    }
  }
  return result;
}
```

指定扁平化的层次
```js
function customFlat(arr, depth = 1) {
  let result = [];

  function flatten(arr, currDepth) {
    for (let i = 0; i < arr.length; i++) {
      if (Array.isArray(arr[i]) && currDepth < depth) {
        flatten(arr[i], currDepth + 1); // 递归调用 flatten 方法，并增加当前深度
      } else {
        result.push(arr[i]);
      }
    }
  }

  flatten(arr, 0);

  return result;
}
```

## 洋葱模型
```js
async function mid1(ctx, next) {
  console.log(1);
  await next();
  console.log(4);
}

async function mid2(ctx, next) {
  console.log(2);
  await next();
  console.log(5);
}

async function mid3(ctx, next) {
  console.log(3);
  await next();
  console.log(6);
}

function compose(middleware) {
  return function (ctx) {
    async function dispatch(i) {
      if (i === middleware.length) {
        // 所有中间件函数执行完毕
        return;
      }

      try {
        const fn = middleware[i];
        await fn(ctx, () => dispatch(i + 1));
      } catch (err) {
        console.error(err);
      }
    }

    return dispatch(0);
  }
}

const middleware = [mid1, mid2, mid3];
compose(middleware)({});
```