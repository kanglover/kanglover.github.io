---
layout: post
title: 语义化版本号（Semantic Versioning）
date: 2025-02-08
author: shaokang
header-img:
catalog: true
tags:
    - git
    - npm
---

## 语义化版本号（Semantic Versioning）

[SemVer](https://semver.org/lang/zh-CN/) 是一种用于软件版本的命名约定，根据语义进行版本控制，使得版本号更加明确和易于理解。它可以帮助开发者和团队更好地管理代码版本，避免代码的不一致性和混乱。npm 的版本策略就是依赖 node-semver 来控制的。

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

1. 主版本号：当你做了不兼容的 API 修改，
2. 次版本号：当你做了向下兼容的功能性新增，
3. 修订号：当你做了向下兼容的问题修正。

先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

### 标准版本号格式

一个简单的版本号是由三个部分组成的

```
MAJOR.MINOR.PATCH
```

MAJOR 表示主版本号，MINOR 表示次版本号，PATCH 表示修订号。

它们的取值为非负整数，若大于零，不能在前方补零。

### 先行版本号（Pre-release Version）

开发过程，往往还伴随着 内测、 公测、 生产候选 等种版本形式。于是，在 “标准版本号” 的基础上又增加了一个新的版本号区域：pre-release 区。

先行版本号的典型格式是 -alpha.1 这样的形式，它由 一个短横线 + 一个字符串组成。

短横线： -
字符串：由大小写的字母、数字、句点 组成。

举例如下：

```
1.0​​.0-1
1.0​​.0-alpha
1.0.0-alpha.1
1.0.0-0.1.1
1.0.0-x.y.z.1
```

常见的先行版本号名称：

-   alpha
-   beta
-   rc

一般而言，先行版本号命名方式：版本号名称.版本号

```
1.0​​.0-alpha.1   内测的第一个版本
1.0.0-beta.1    灰度测试的第一个版本
1.0.0-rc.1      生产候选的第一个版本
```

先后顺序：1.0.0-alpha < 1.0.0-beta < 1.0.0-rc < 1.0.0

> 注意：先行版本是小于标准版本号要低，在比较版本号时，先行版本号会被认为是低于其对应的标准版本号的。

## SemVer 使用

通过 yarn、npm 等包管理工具都可以轻松安装。

-   校验一个版本号是否合法：

```js
semver.valid('1.2.3'); // '1.2.3'
semver.valid('a.b.c'); // null
```

-   清除版本号里一些多余的语句：

```js
semver.clean('  =v1.2.3   '); // '1.2.3'
```

-   比较版本号的大小

```js
semver.gt('1.2.3', '9.8.7'); // false
semver.lt('1.2.3', '9.8.7'); // true
```

## npm 指令升级版本

通过执行[指令](https://docs.npmjs.com/cli/v8/commands/npm-version)来升级项目版本

```bash
npm version major
# 1.2.3 => 2.2.3

npm version minor
# 1.2.3 => 1.3.3

npm version patch
# 1.2.3 => 1.2.4

npm version premajor
# 1.2.3 => 2.0.0-0

npm version prerelease
# 1.2.3 => 1.2.4-0

npm version prerelease --preid=alpha
# 1.2.3 => 1.2.4-alpha.0
```

可以通过 npm view xxx versions 查看某个包的版本号

## 版本规则

### 破折号策略（-）

```
1.2.3 - 2.3.4 // 代表 >=1.2.3 <=2.3.4 之间的版本，包含左右版本。
```

如果起始版本（左侧的版本）有空缺，将以 0 补位：

```
1.2 - 2.3.4 // 代表 >=1.2.0 <=2.3.4
```

如果结尾版本（右侧的版本）有空缺，将以 0 补位，并且递增非 0 版本号作为最大版本号：

```
1.2.3 - 2.3 // >=1.2.3 <2.4.0

1.2.3 - 2 // >=1.2.3 < 3.0.0
```

### 泛版本策略（\*）

可以使用 X, x, or \* 来作为某个版本号的占位符，来示意所有可能的版本号。

```
* // 代表 >=0.0.0 (所有版本)

1.x // 代表 >=1.0.0 <2.0.0 (主版本限定为 1 的版本号)

1.2.x // 代表 >=1.2.0 <1.3.0 (主版本+次版本限定为 1.2 的版本号)
```

如果我们版本号有缺损，将为我们自动以占位符填充：

```
"" (empty string) // 代表 * 即 >=0.0.0

1 // 代表 1.x.x 即 >=1.0.0 <2.0.0

1.2 // 代表 1.2.x 即 >=1.2.0 <1.3.0
```

### 波浪策略（~）

当前版本号为起始版本，以倒数第二个版本号+1（次版本号 Y）为递增版本，可更新 [起始，结束) 范围内的所有版本号。

如有版本号有空缺，将自动补 0，并以最近的空缺版本之前的版本号+1 作为递增的最大版本号。

对于 0.Y.Z 的开发阶段的版本号，将递增 0 后面的版本号作为递增的最大版本号。

```
~1.2.3 // 代表 >=1.2.3 <1.(2+1).0 即 >=1.2.3 <1.3.0

~1.2 // 代表 >=1.2.0 <1.(2+1).0 即 >=1.2.0 <1.3.0 (等同 1.2.x)

~1 // 代表 >=1.0.0 <(1+1).0.0 即 >=1.0.0 <2.0.0 (等同 1.x)

~0.2.3 // 代表 >=0.2.3 <0.(2+1).0 即 >=0.2.3 <0.3.0

~0.2 // 代表 >=0.2.0 <0.(2+1).0 即 >=0.2.0 <0.3.0 (等同 0.2.x)

~0 // 代表 >=0.0.0 <(0+1).0.0 即 >=0.0.0 <1.0.0 (等同 0.x)

~1.2.3-beta.2 // 代表 >=1.2.3-beta.2 <1.3.0
```

### 倒三角策略（^）

更新主版本号，如果版本号为 0，则往下取非 0 版本号递增，作为最大版本号。

```
^1.2.3 // 代表 >=1.2.3 <2.0.0
^0.2.3 // 代表 >=0.2.3 <0.3.0
^0.0.3 // 代表 >=0.0.3 <0.0.4
^1.2.3-beta.2 // 代表 >=1.2.3-beta.2 <2.0.0
^0.0.3-beta // 代表 >=0.0.3-beta <0.0.4
```

对于泛版本，以及空缺版本的示例：

```
^1.2.x // 代表 >=1.2.0 <2.0.0
^0.0.x // 代表 >=0.0.0 <0.1.0
^0.0 // 代表 >=0.0.0 <0.1.0
^1.x // 代表 >=1.0.0 <2.0.0
^0.x // 代表 >=0.0.0 <1.0.0
```
