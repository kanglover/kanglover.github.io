---
layout:     post
title:      工程化
date:       2022-02-23
author:     shaokang
catalog: true
tags:
    - 复习
---

## 模块化规范
[参考资料](https://segmentfault.com/a/1190000017466120)

### 模块
将一个复杂的程序依据一定的规则(规范)封装成几个块(文件), 并进行组合在一起
块的内部数据与实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信

### 历史进程
全局 function 模式 => namespace 模式 => IIFE 自执行 => 模块化规范
全局变量、命名冲突 => 数据污染 => 多个 script 多请求、依赖顺序

### 模块化的好处
* 避免命名冲突(减少命名空间污染)
* 更好的分离, 按需加载
* 更高复用性
* 高可维护性

### 模块化规范
#### 1. CommonJS 规范
一个文件为一个模块，通过 require 方法来同步加载依赖的模块，exports / module.exports 导出暴露的接口。

优点：服务器端模块重用，NPM中模块包多，有将近20万个。  
缺点：加载模块是同步的，只有加载完成后才能执行后面的操作，也就是当要用到该模块了，现加载现用，不仅加载速度慢，而且还会导致性能、可用性、调试和跨域访问等问题。Node.js主要用于服务器编程，加载的模块文件一般都存在本地硬盘，加载起来比较快，不用考虑异步加载的方式，因此，CommonJS 规范比较适用。然而，这并不适合在浏览器环境，同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。

实现：服务器端的 Node.js；Browserify；

#### 2. AMD 规范
适配浏览器，可以实现异步加载依赖模块，并且会提前执行。

优点：在浏览器环境中异步加载模块；并行加载多个模块；  
缺点：开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现；

实现：RequireJS； curl；

#### 3. CMD
Common Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。

优点：依赖就近，延迟执行 可以很容易在 Node.js 中运行；  
缺点：依赖 SPM 打包，模块的加载逻辑偏重；

实现：Sea.js ；coolie

#### AMD 和 CMD 区别：
* 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
* AMD 推崇依赖前置，CMD 推崇依赖就近。

#### ES6 Module 和 CommonJS 模块的区别：
* CommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变，类似const；
* import 的接⼝是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对 commonJS 对重新赋值（改变指针指向），但是对 ES6 Module赋值会编译报错。 
* CommonJS 是执行阶段进行模块解析，ES6 Module 是编译阶段解析。
* this 的指向不同，CommonJS this 指向当前 module 的默认 exports，ES6 Module 执行 undefined。

相同点：
都有缓存：都会缓存模块，模块加载一次后会缓存起来，后续再次加载会用缓存里的模块。


## 构建工具
### 1. webpack
#### 基本知识点 1 - module、chunk 和 bundle
module: 只要是文件，都是一个module  
chunk: 代码块，是webpack根据功能拆分出来的（chunk是无法在打包结果中看到的，打包结果中看到的是bundle），包含三种情况:
* 你的项目入口(entry)
* 通过import()动态引入的代码
* 通过splitChunks拆分出来的代码

bundle: bundle是webpack打包之后的各个文件，一般就是和chunk是一对一的关系，bundle就是对chunk进行编译压缩打包等处理之后的产出。

我们直接写出来的是 module，webpack 处理时是 chunk，最后生成浏览器可以直接运行的 bundle。
[参考](https://www.cnblogs.com/skychx/p/webpack-module-chunk-bundle.html)

#### 基本知识点 2 - hash、chunkhash、contenthash
hash 计算与整个项目的构建相关；  
chunkhash 计算与同一 chunk 内容相关；  
contenthash 计算与文件内容本身相关。[参考](https://www.cnblogs.com/skychx/p/webpack-hash-chunkhash-contenthash.html)

#### 基本知识点 3 - devtool
inline: Source Map内容通过base64放在js文件中引入。  
hidden: 代码中没有sourceMappingURL，浏览器不自动引入Source Map。  
eval: 生成代码和Source Map内容混淆在一起，通过eval输出。  
nosources: 使用这个关键字的Source Map不包含sourcesContent，调试时只能看到文件信息和行信息，无法看到源码。  
cheap: 不包含列信息，并且源码是进过loader处理过的  
cheap-module: 不包含列信息，源码是开发时的代码
[参考](https://juejin.cn/post/6844904201311485966#heading-4)  

#### 基本知识点 4 - webpack 中，filename 和 chunkFilename 的区别是什么？
filename 指列在 entry 中，打包后输出的文件的名称。  
chunkFilename 指未列在 entry 中，却又需要被打包出来的文件的名称。
[参考](https://www.cnblogs.com/skychx/p/webpack-filename-chunkFilename.html)

#### 基本知识点 5 - SplitChunks
chunks选项，决定要提取那些模块。
默认是async：只提取异步加载的模块出来打包到一个文件中。
异步加载的模块：通过import('xxx')或require(['xxx'],() =>{})加载的模块。  
initial：提取同步加载和异步加载模块，如果xxx在项目中异步加载了，也同步加载了，那么xxx这个模块会被提取两次，分别打包到不同的文件中。
同步加载的模块：通过 import xxx或require('xxx')加载的模块。  
all：不管异步加载还是同步加载的模块都提取出来，打包到一个文件中。
[参考](https://zhuanlan.zhihu.com/p/152097785)

#### 基本知识点 6 - webpackChunkName、webpackPrefetch、webpackPreload
webpackChunkName 是为预加载的文件取别名  
webpackPrefetch 会在浏览器闲置下载文件  
webpackPreload 会在父 chunk 加载时并行下载文件。


Re: [一文吃透 Webpack 核心原理](https://mp.weixin.qq.com/s/SbJNbSVzSPSKBe2YStn2Zw)

### 2. vite
现在常用的构建工具如 webpack，主要是通过抓取 - 编译 - 构建整个应用的代码生成一份编译、优化后能良好兼容各个浏览器的生产环境代码。在开发环境流程也基本相同，需要先将整个应用构建打包后，再把打包后的代码交给 dev server。

webpack 等构建工具的诞生给前端开发带来了极大的便利，但随着前端业务的复杂化，js 代码量呈指数增长，打包构建时间越来越久，dev server 性能遇到瓶颈：
* 缓慢的服务启动：大型项目中 dev server 启动时间达到几十秒甚至几分钟
* 缓慢的 HMR 热更新: 即使采用了 HMR 模式，其热更新速度也会随着应用规模的增长而显著下降，

缓慢的开发环境，大大降低了开发者的幸福感，在以上背景下 vite 应运而生。

### 什么是 vite ？
基于 esbuild 与 rollup 依赖浏览器自身 ESM 编译功能，实现极致开发体验的新一代构建工具。

#### 开发环境
* 利用浏览器原生的 ES Module 编译能力，省略费时的编译环节，直给浏览器开发环境源码，dev server 只提供轻量服务。
* 浏览器执行 ESM 的 import 时，会向 dev server 发起该模块的 ajax 请求，服务器对源码做简单处理后返回给浏览器。
* Vite 中 HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块失活，使得无论应用大小如何，HMR 始终能保持快速更新。
使用 esbuild 处理项目依赖，esbuild 使用 go 编写，比一般 node.js 编写的编译器快几个数量级。
#### 生产环境
集成 Rollup 打包生产环境代码，依赖其成熟稳定的生态与更简洁的插件机制。

#### 处理流程对比
Webpack 通过先将整个应用打包，再将打包后代码提供给dev server，开发者才能开始开发。  
Vite 直接将源码交给浏览器，实现 dev server 秒开，浏览器显示页面需要相关模块时，再向 dev server 发起请求，服务器简单处理后，将该模块返回给浏览器，实现真正意义的按需加载。

#### 实现原理
ESbuild 编译

依赖预构建
* 模块化兼容：Vite 在预构建阶段将依赖中各种其他模块化规范(CommonJS、UMD)转换成 ESM，以提供给浏览器。
* 性能优化：npm 包中大量的 ESM 代码，大量的 import 请求，会造成网络拥塞。Vite 使用 esbuild，将有大量内部模块的 ESM 关系转换成单个模块，以减少 import 模块请求次数。

按需加载
* 服务器只在接受到 import 请求的时候，才会编译对应的文件，将 ESM 源码返回给浏览器，实现真正的按需加载。

缓存
* HTTP缓存： 充分利用 http 缓存做优化，依赖（不会变动的代码）部分用 max-age,immutable 强缓存，源码部分用 304 协商缓存，提升页面打开速度。
* 文件系统缓存： Vite 在预构建阶段，将构建后的依赖缓存到 node_modules/.vite，相关配置更改时，或手动控制时才会重新构建，以提升预构建速度。

重写模块路径  
浏览器import只能引入相对/绝对路径，而开发代码经常使用npm包名直接引入node_module中的模块，需要做路径转换后交给浏览器。
* es-module-lexer 扫描 import 语法
* magic-string 重写模块的引入路径
```
// 开发代码
import { createApp } from 'vue'

// 转换后
import { createApp } from '/node_modules/vue/dist/vue.js'
```

#### 优势
* 快！快！非常快！！
* 高度集成，开箱即用。
* 基于 ESM 急速热更新，无需打包编译。
* 基于 esbuild 的依赖预处理，比 Webpack 等 node 编写的编译器快几个数量级。
* 兼容 Rollup 庞大的插件机制，插件开发更简洁。
* 不与 Vue 绑定，支持 React 等其他框架，独立的构建工具。
* 内置 SSR 支持。
* 天然支持 TS。

## Tree Shaking
Tree-Shaking 是一种基于 ES Module 规范的 Dead Code Elimination 技术，它会在运行过程中静态分析模块之间的导入导出，确定 ESM 模块中哪些导出值未曾其它模块使用，并将其删除，以此实现打包产物的优化。

Re: [Tree-Shaking 实现原理](https://juejin.cn/post/7002410645316436004)

### 实现原理
Webpack 中，Tree-shaking 的实现一是先标记出模块导出值中哪些没有被用过，二是使用 Terser 删掉这些没被用到的导出语句。标记过程大致可划分为三个步骤：

* Make 阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中
* Seal 阶段，遍历 ModuleGraph 标记模块导出变量有没有被使用
* 生成产物时，若变量没有被其它模块使用则删除对应的导出语句


#### 1. 收集模块导出
* 将模块的所有 ESM 导出语句转换为 Dependency 对象，并记录到 module 对象的 dependencies 集合
* 所有模块都编译完毕后，触发 compilation.hooks.finishModules 钩子，开始执行 FlagDependencyExportsPlugin 插件回调
* FlagDependencyExportsPlugin 插件从 entry 开始读取 ModuleGraph 中存储的模块信息，遍历所有 module 对象
* 遍历 module 对象的 dependencies 数组，找到所有 HarmonyExportXXXDependency 类型的依赖对象，将其转换为 ExportInfo 对象并记录到 ModuleGraph 体系中

#### 2. 标记模块导出
遍历 module 对象对应的 exportInfo 数组，确定其对应的 Dependency 对象是否被其他模块使用

#### 3. 生成代码
* import 被标记为 /* harmony import */
* 被使用过的export标记为 /* harmony export([type]) */，其中[type]和webpack内部有关，可能是binding，immutable等。
* 没有被使用的export标记为/* unused harmony export [FuncName] */，其中[FuncName]为export的方法名。

#### 4. 删除 Dead Code
Terser、UglifyJS 等 DCE 工具“摇”掉标记中无效的代码。

#### 总结
1. 根据模块的 dependencies 列表收集模块导出值，并记录到 ModuleGraph 体系的 exportsInfo 中。
2. 收集模块的导出值的使用情况，并记录到 exportInfo._usedInRuntime 集合中。
3. 根据导出值的使用情况生成不同的导出语句。
4. 使用 DCE 工具删除 Dead Code，实现完整的树摇效果。
